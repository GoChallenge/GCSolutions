package drum

import (
	"bytes"
	"fmt"
	"testing"
)

var tracks = []Track{
	Track{0, "test1", [4][4]Step{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}},
	Track{1, "test2", [4][4]Step{{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}}},
	Track{2, "test3", [4][4]Step{{0, 0, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}},
}

func TestPatternString(t *testing.T) {

	tData := []struct {
		pattern Pattern
		output  string
	}{
		{
			Pattern{"0.808-alpha", 123, []Track{tracks[0]}},
			`Saved with HW Version: 0.808-alpha
Tempo: 123
(0) test1	|----|----|----|----|
`,
		},
		{
			Pattern{"0.808-alpha", 123, []Track{}},
			`Saved with HW Version: 0.808-alpha
Tempo: 123

`,
		},
		{
			Pattern{"0.808", 123, []Track{tracks[0], tracks[1], tracks[2]}},
			`Saved with HW Version: 0.808
Tempo: 123
(0) test1	|----|----|----|----|
(1) test2	|xxxx|xxxx|xxxx|xxxx|
(2) test3	|----|xxxx|----|----|
`,
		},
	}

	for _, exp := range tData {
		if fmt.Sprint(exp.pattern) != exp.output {
			t.Fatalf("Pattern wasn't converted to string as expect.\nGot:\n%s\nExpected:\n%s",
				exp.pattern, exp.output)
		}
	}
}

func TestPatternDecode(t *testing.T) {
	tData := []struct {
		pattern  Pattern
		encoding []byte
	}{
		{
			Pattern{"0.808-alpha", 120, []Track{tracks[0]}},
			[]byte{
				0x53, 0x50, 0x4C, 0x49, 0x43, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				0x00, 0x3E,
				0x30, 0x2E, 0x38, 0x30, 0x38, 0x2D, 0x61, 0x6C, 0x70, 0x68, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				0x00, 0x00, 0xF0, 0x42,

				0x00, 0x00, 0x00, 0x00,
				0x05,
				't', 'e', 's', 't', '1',
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
		},
		{
			Pattern{"0.909", 999, []Track{tracks[0], tracks[1], tracks[2]}},
			[]byte{
				0x53, 0x50, 0x4C, 0x49, 0x43, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				0x00, 0x72,
				0x30, 0x2E, 0x39, 0x30, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				0x00, 0xc0, 0x79, 0x44,

				0x00, 0x00, 0x00, 0x00,
				0x05,
				't', 'e', 's', 't', '1',
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,

				0x01, 0x00, 0x00, 0x00,
				0x05,
				't', 'e', 's', 't', '2',
				0x01, 0x01, 0x01, 0x01,
				0x01, 0x01, 0x01, 0x01,
				0x01, 0x01, 0x01, 0x01,
				0x01, 0x01, 0x01, 0x01,

				0x02, 0x00, 0x00, 0x00,
				0x05,
				't', 'e', 's', 't', '3',
				0x00, 0x00, 0x00, 0x00,
				0x01, 0x01, 0x01, 0x01,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
		},
	}

	for _, exp := range tData {

		buf := bytes.NewBuffer(exp.encoding)
		p := Pattern{}

		if err := p.Decode(buf); err != nil {
			t.Errorf("Unexpected error: %v", err)
		}

		if p.Version != exp.pattern.Version {
			t.Errorf("Version string does not match: got '%s' expected '%s'", p.Version, exp.pattern.Version)
		}

		if p.Tempo != exp.pattern.Tempo {
			t.Errorf("Tempo does not match: got '%f' expected '%f'", p.Tempo, exp.pattern.Tempo)
		}

		for index, track := range p.Tracks {
			if track.String() != exp.pattern.Tracks[index].String() {
				t.Errorf("Tracks do not match: got '%s' expected '%s'", p.Tracks, exp.pattern.Tracks)
			}
		}
	}
}
